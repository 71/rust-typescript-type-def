use serde::Serialize;
use std::collections::{HashMap, HashSet};
use typescript_type_def::{
    type_expr::{CustomTypeInfo, Ident, TypeExpr, TypeInfo, TypeName},
    write_definition_file,
    TypeDef,
};

fn test_emit<T>() -> String
where
    T: TypeDef,
{
    let mut buf = Vec::new();
    write_definition_file::<_, T>(&mut buf).unwrap();
    String::from_utf8(buf).unwrap()
}

macro_rules! assert_eq_str {
    ($actual:expr, $expected:expr) => {{
        let actual = $actual;
        let expected = $expected;
        ::difference::assert_diff!(expected, actual.as_str(), "\n", 0);
    }};
}

#[test]
fn emit() {
    type Inner = Vec<HashMap<Option<usize>, HashSet<String>>>;

    #[derive(Serialize)]
    struct Test(Inner);

    impl TypeDef for Test {
        type Deps = (Inner,);

        const INFO: TypeInfo = TypeInfo::Custom(CustomTypeInfo {
            docs: None,
            name: &TypeName::ident(&Ident("Test")),
            def: &TypeExpr::Ref(Inner::INFO),
        });
    }

    // TODO: remove boilerplate for tests
    assert_eq_str!(
        test_emit::<Test>(),
        r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Usize=number;
export type Test=(Record<(types.Usize|null),(string)[]>)[];
}
"#
    );
}

mod derive {
    #![allow(dead_code)]

    use super::*;

    #[derive(Serialize, TypeDef)]
    #[serde(rename_all = "SCREAMING_SNAKE_CASE")]
    struct Parent {
        foo_bar: usize,
    }

    #[derive(Serialize, TypeDef)]
    struct Test {
        #[serde(flatten)]
        parent: Parent,
        a: String,
        b: Option<usize>,
        #[serde(skip_serializing_if = "Option::is_none")]
        c: Option<Vec<bool>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        d: Option<u8>,
    }

    #[derive(Serialize, TypeDef)]
    struct Test2(Test, usize, String);

    #[derive(Serialize, TypeDef)]
    struct Test3(Test2);

    #[derive(Serialize, TypeDef)]
    #[serde(untagged)]
    enum Test4 {
        A(Test3),
        B(String, usize),
        C { a: String, b: usize },
    }

    #[derive(Serialize, TypeDef)]
    #[serde(rename_all = "kebab-case")]
    enum Test5 {
        A,
        B,
        CoolBeans,
    }

    #[derive(Serialize, TypeDef)]
    enum Test6 {
        A { a: usize },
        B(usize, String),
        C(String),
        D,
    }

    #[derive(Serialize, TypeDef)]
    #[serde(tag = "type", content = "value")]
    enum Test7 {
        A {
            a: String,
            b: usize,
        },
        #[serde(rename_all = "UPPERCASE")]
        B {
            a: Test4,
            b: Test5,
            c: Test6,
        },
        C(Parent),
        D,
    }

    #[test]
    fn emit() {
        assert_eq_str!(
            test_emit::<Test7>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Usize=number;
export type Parent={"FOO_BAR":types.Usize;};
export type U8=number;
export type Test=(types.Parent&{"a":string;"b":(types.Usize|null);"c"?:(boolean)[];"d"?:types.U8;});
export type Test2=[types.Test,types.Usize,string];
export type Test3=types.Test2;
export type Test4=(types.Test3|[string,types.Usize]|{"a":string;"b":types.Usize;});
export type Test5=("a"|"b"|"cool-beans");
export type Test6=({"A":{"a":types.Usize;};}|{"B":[types.Usize,string];}|{"C":string;}|"D");
export type Test7=({"type":"A";"value":{"a":string;"b":types.Usize;};}|{"type":"B";"value":{"A":types.Test4;"B":types.Test5;"C":types.Test6;};}|{"type":"C";"value":types.Parent;}|{"type":"D";});
}
"#
        );
    }

    #[test]
    fn json() {
        assert_eq_str!(
            serde_json::to_string(&Test7::B {
                a: Test4::A(Test3(Test2(
                    Test {
                        parent: Parent {
                            foo_bar: 123
                        },
                        a: "foo".to_owned(),
                        b: None,
                        c: Some(vec![true, false]),
                        d: None,
                    },
                    4,
                    "bar".to_owned(),
                ))),
                b: Test5::CoolBeans,
                c: Test6::B(42, "baz".to_owned()),
            })
            .unwrap(),
            r#"{"type":"B","value":{"A":[{"FOO_BAR":123,"a":"foo","b":null,"c":[true,false]},4,"bar"],"B":"cool-beans","C":{"B":[42,"baz"]}}}"#
        );
    }

    mod enum_tags {
        #![allow(dead_code)]

        use super::*;

        #[derive(Clone, Copy, Serialize, TypeDef)]
        struct Inner {
            x: bool,
        }

        const INNER: Inner = Inner { x: true };

        #[test]
        fn tag() {
            #[derive(Serialize, TypeDef)]
            #[serde(tag = "type")]
            enum Test {
                A { a: Inner },
                B(Inner),
                // C(Inner, Inner), // not allowed
                D,
            }

            assert_eq_str!(
            test_emit::<Test>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Inner={"x":boolean;};
export type Test=(({"type":"A";}&{"a":types.Inner;})|({"type":"B";}&types.Inner)|{"type":"D";});
}
"#
        );
            assert_eq_str!(
                serde_json::to_string(&Test::A { a: INNER }).unwrap(),
                r#"{"type":"A","a":{"x":true}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::B(INNER)).unwrap(),
                r#"{"type":"B","x":true}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::D).unwrap(),
                r#"{"type":"D"}"#
            );
        }

        #[test]
        fn tag_content() {
            #[derive(Serialize, TypeDef)]
            #[serde(tag = "type", content = "value")]
            enum Test {
                A { a: Inner },
                B(Inner),
                C(Inner, Inner),
                D,
            }

            assert_eq_str!(
            test_emit::<Test>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Inner={"x":boolean;};
export type Test=({"type":"A";"value":{"a":types.Inner;};}|{"type":"B";"value":types.Inner;}|{"type":"C";"value":[types.Inner,types.Inner];}|{"type":"D";});
}
"#);
            assert_eq_str!(
                serde_json::to_string(&Test::A { a: INNER }).unwrap(),
                r#"{"type":"A","value":{"a":{"x":true}}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::B(INNER)).unwrap(),
                r#"{"type":"B","value":{"x":true}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::C(INNER, INNER)).unwrap(),
                r#"{"type":"C","value":[{"x":true},{"x":true}]}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::D).unwrap(),
                r#"{"type":"D"}"#
            );
        }

        #[test]
        fn untagged() {
            #[derive(Serialize, TypeDef)]
            #[serde(untagged)]
            enum Test {
                A { a: Inner },
                B(Inner),
                C(Inner, Inner),
                D,
            }

            assert_eq_str!(
            test_emit::<Test>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Inner={"x":boolean;};
export type Test=({"a":types.Inner;}|types.Inner|[types.Inner,types.Inner]|null);
}
"#
        );
            assert_eq_str!(
                serde_json::to_string(&Test::A { a: INNER }).unwrap(),
                r#"{"a":{"x":true}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::B(INNER)).unwrap(),
                r#"{"x":true}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::C(INNER, INNER)).unwrap(),
                r#"[{"x":true},{"x":true}]"#
            );
            assert_eq_str!(serde_json::to_string(&Test::D).unwrap(), r#"null"#);
        }

        #[test]
        fn none() {
            #[derive(Serialize, TypeDef)]
            enum Test {
                A { a: Inner },
                B(Inner),
                C(Inner, Inner),
                D,
            }

            assert_eq_str!(
            test_emit::<Test>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{
export type Inner={"x":boolean;};
export type Test=({"A":{"a":types.Inner;};}|{"B":types.Inner;}|{"C":[types.Inner,types.Inner];}|"D");
}
"#
        );
            assert_eq_str!(
                serde_json::to_string(&Test::A { a: INNER }).unwrap(),
                r#"{"A":{"a":{"x":true}}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::B(INNER)).unwrap(),
                r#"{"B":{"x":true}}"#
            );
            assert_eq_str!(
                serde_json::to_string(&Test::C(INNER, INNER)).unwrap(),
                r#"{"C":[{"x":true},{"x":true}]}"#
            );
            assert_eq_str!(serde_json::to_string(&Test::D).unwrap(), r#""D""#);
        }
    }

    #[test]
    fn docs() {
        /// enum `Test`
        #[derive(Serialize, TypeDef)]
        enum Test {
            /// struct variant `Test::A`
            A {
                /// struct variant field `Test::A.a`
                a: String,
            },
            /// newtype variant `Test::B`
            B(
                /// newtype variant field `Test::B.0`
                String,
            ),
            /// tuple variant `Test::C`
            C(
                /// tuple variant field `Test::C.0`
                String,
                /// tuple variant field `Test::C.1`
                String,
            ),
            /// unit variant `Test::D`
            D,
        }

        assert_eq_str!(
            test_emit::<Test>(),
            r#"// AUTO-GENERATED by typescript-type-def

export default types;
export namespace types{

/**
 * enum `Test`
 */
export type Test=({
/**
 * struct variant `Test::A`
 */
"A":{
/**
 * struct variant field `Test::A.a`
 */
"a":string;};}|{
/**
 * newtype variant `Test::B`
 */
"B":string;}|{
/**
 * tuple variant `Test::C`
 */
"C":[string,string];}|
/**
 * unit variant `Test::D`
 */
"D");
}
"#
        );
    }
}
